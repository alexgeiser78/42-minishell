GNU Readline library
https://tiswww.case.edu/php/chet/readline/readline.html

basics Shell
https://www.youtube.com/watch?v=hMSByvFHOro&list=PLGU1kcPKHMKj5yA0RPb5AK4QAhexmQwrW 

command lines:
                chsh -s /bin/zsh    //changing terminal shell to zsh
                chsh -s /bin/bash   //changing terminal shell to bash
                PS1= "else"         //changing prompt name
                pushd /Downloads    //jumping from a dir to 
                popd                //come back
                file .git           //what kind of file
                locate ....         //search
                which  ...          //which command is installed
                cal                 //calender
                history             //comand lines tiped
                !numberfromhistory  //exec the line from history
                whatis  ...         //short description of the command
                apropos  ...        //search for command related to ...
                find ...            //find
                printf > xxx.txt    //writes in file
                echo   > xxx.txt    //writes in file
                less ...            //print the file like cat but read from the top
                grep 'abc' ./file/  //search for word in a file
                sed "s/[ab]/c/g"    //replace every a or b by a c
                |                   //piping take the result before | to do what is after
                sort                //sort
                ./                  //execute a shell script
                sudo !!             //!! = last command line typed
                kill                //stops a program running
                xkill               //to kill a process clicking on it
                ping google.com     //check if yout connected
                wget http...        //to download a file on internet
                date                //date
                bc                  //calculator
                set | less          //envirronement of bash
                . .bashrc           //relaod the .bashrc file
                >                   //redirection

directories:

./bashrc                            //file to edit the settings
        alias   xxx='xxx ls'        //is like #define xvariable (shortcut)
        function () {}              //function

/etc/bashrc                         //main file of bash


script:

#!/bin/sh                           //hashbang
echo "Hello World!"
exit

Functions used: add_history, malloc, rl_on_new_line, rl_redisplay,
        signal, fork, free, write, execve, waitpid, rl_replace_line,
        isatty, getenv, readline, open, perror,
        

Functions autorised:
         rl_clear_history, 
        
        printf, access,  read,
        close, wait, wait3, wait4, 
        sigaction, sigemptyset, sigaddset, kill, exit,
        getcwd, chdir, stat, lstat, fstat, unlink, 
        dup, dup2, pipe, opendir, readdir, closedir,
        strerror,   ttyname, ttyslot, ioctl,
        getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
        tgetnum, tgetstr, tgoto, tputs

        receive command
        read commant 
        interpret command (search the directory of the command)
        execute the command


MANDATORY:
          prompt, historic, PATH, ', ", >, >>, <, <<, |, $, $?, ctrl-C, ctrl-D, ctrl-\ 
            ◦ echo with option -n
            ◦ cd uniquement avec un chemin relatif ou absolu
            ◦ pwd
            ◦ export // add line to envirronement
            ◦ unset
            ◦ env
            ◦ exit

BONUS:
         &&, ||, ()
         wildcards *

  redirections:

  standard input //user keyboard
  standard output, error output //on screen ouput
  < write in file
  > capture from file
  << >> write or capture to the end of file


  -what is a node? the line, a art of the line? from env
  -what is g_status?
  -what is isatty?
  -explain $?
  -ft_isvariable not understand
  -child process finished?


                                              
                                              workflow
main
 |->t_minishell	data;
 |->init_minishell
       |->init env
            |->ft_array_size
            |->ft_split_env
                    |->ft_strchr(line, '=')
            |->ft_create_new_node
                  t_env	*result;
            |->ft_insert_at_end
       |->init_term_fd
            |->data->std_in = dup(STDIN_FILENO);
	        |->data->std_out = dup(STDOUT_FILENO);
  while
  {
    signal_handler
    display_prompt_msg
           |->readline
           |->add_history
    |->ft_ctrl_d
         |->isatty
    ft_commands
         |->ft_has_valid_quotes
         |->ft_count_commands
         |->ft_strchr_variable
                |->if ((raw_cmd[i] == '$' && ft_isalnum(raw_cmd[i+1]) && s_quote == 0))
                |->ft_get_export_id
                |->ft_check_var_rules
         |->ft_parse_variables
                |->ft_strchr_variable
                |->ft_get_export_id
                	if (ft_strcmp(variable, "?") == 0)
			            return (ft_replace_string(data->raw_cmd, variable, ft_itoa(g_status.status)));
                    else
		                {
			            if (ft_isvariable(data->lstenv, variable))
			            {
				        tmp = ft_find_id(data->lstenv, variable);
				        result = ft_replace_string(data->raw_cmd, tmp->id, tmp->value);
			            }
			            else
				        result = ft_replace_string(data->raw_cmd, variable, "");
			        return (result);
		            }
          |->ft_init_data_one_cmd
                 |->ft_redirect
                      |->get_filename
                            in_or_from_file
                 |->signal
                 |->is_builtin
                 |->fork
                 |->signal
                 |->exec_one
                      |->find_command_route_env
                             |->ft_isvariable
                             |->getenv
                             |->command_add
                             |->access
                 |->execve
           |->ft_free_one
           |->ft_multiple_commands
                |->ft_check_pipe_sytax
                |->ft_separate_cmds
                |->pipe
                |->signal
                |->fork
                |->signal
                |->child_process       ?
                |->exec_multiple
                     ->find_command_route_env
                             |->ft_isvariable
                             |->getenv
                             |->command_add
                             |->access
                 |->execve
    |->reset_term_fd
  }
  return (g_status.status);
  
            