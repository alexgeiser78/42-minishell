GNU Readline library
https://tiswww.case.edu/php/chet/readline/readline.html

basics Shell
https://www.youtube.com/watch?v=hMSByvFHOro&list=PLGU1kcPKHMKj5yA0RPb5AK4QAhexmQwrW 

command lines:
                chsh -s /bin/zsh    //changing terminal shell to zsh
                chsh -s /bin/bash   //changing terminal shell to bash
                PS1= "else"         //changing prompt name
                pushd /Downloads    //jumping from a dir to 
                popd                //come back
                file .git           //what kind of file
                locate ....         //search
                which  ...          //which command is installed
                cal                 //calender
                history             //comand lines tiped
                !numberfromhistory  //exec the line from history
                whatis  ...         //short description of the command
                apropos  ...        //search for command related to ...
                find ...            //find
                printf > xxx.txt    //writes in file
                echo   > xxx.txt    //writes in file
                less ...            //print the file like cat but read from the top
                grep 'abc' ./file/  //search for word in a file
                sed "s/[ab]/c/g"    //replace every a or b by a c
                |                   //piping take the result before | to do what is after
                sort                //sort
                ./                  //execute a shell script
                sudo !!             //!! = last command line typed
                kill                //stops a program running
                xkill               //to kill a process clicking on it
                ping google.com     //check if yout connected
                wget http...        //to download a file on internet
                date                //date
                bc                  //calculator
                set | less          //envirronement of bash
                . .bashrc           //relaod the .bashrc file
                >                   //redirection

directories:

./bashrc                            //file to edit the settings
        alias   xxx='xxx ls'        //is like #define xvariable (shortcut)
        function () {}              //function

/etc/bashrc                         //main file of bash


script:

#!/bin/sh                           //hashbang
echo "Hello World!"
exit

Functions used: add_history, malloc, rl_on_new_line, rl_redisplay,
        signal, fork, free, write, execve, waitpid, rl_replace_line,
        isatty, getenv, readline, open, perror,
        

Functions autorised:
         rl_clear_history, 
        
        printf, access,  read,
        close, wait, wait3, wait4, 
        sigaction, sigemptyset, sigaddset, kill, exit,
        getcwd, chdir, stat, lstat, fstat, unlink, 
        dup, dup2, pipe, opendir, readdir, closedir,
        strerror,   ttyname, ttyslot, ioctl,
        getenv, tcsetattr, tcgetattr, tgetent, tgetflag,
        tgetnum, tgetstr, tgoto, tputs

        receive command
        read commant 
        interpret command (search the directory of the command)
        execute the command


MANDATORY:
          prompt, historic, PATH, ', ", >, >>, <, <<, |, $, $?, ctrl-C, ctrl-D, ctrl-\ 
            ◦ echo with option -n
            ◦ cd uniquement avec un chemin relatif ou absolu
            ◦ pwd
            ◦ export // add line to envirronement
            ◦ unset
            ◦ env
            ◦ exit

BONUS:
         &&, ||, ()
         wildcards *

  redirections:

  standard input //user keyboard
  standard output, error output //on screen ouput
  < write in file
  > capture from file
  << >> write or capture to the end of file


  -what is a node? the line, a art of the line? from env
  -what is g_status?
  -what is isatty?
  -explain $?
  -ft_isvariable not understand
  -child process finished?


                                              
                                              workflow
main
 |->t_minishell	data;
 |->init_minishell
       |->init env
            |->ft_array_size
            |->ft_split_env
                    |->ft_strchr(line, '=')
            |->ft_create_new_node
                  t_env	*result;
            |->ft_insert_at_end
       |->init_term_fd
            |->data->std_in = dup(STDIN_FILENO);
	        |->data->std_out = dup(STDOUT_FILENO);
  while
  {
    signal_handler
    display_prompt_msg
           |->readline
           |->add_history
    |->ft_ctrl_d
         |->isatty
    ft_commands
         |->ft_has_valid_quotes
         |->ft_count_commands
         |->ft_strchr_variable
                |->if ((raw_cmd[i] == '$' && ft_isalnum(raw_cmd[i+1]) && s_quote == 0))
                |->ft_get_export_id
                |->ft_check_var_rules
         |->ft_parse_variables
                |->ft_strchr_variable
                |->ft_get_export_id
                	if (ft_strcmp(variable, "?") == 0)
			            return (ft_replace_string(data->raw_cmd, variable, ft_itoa(g_status.status)));
                    else
		                {
			            if (ft_isvariable(data->lstenv, variable))
			            {
				        tmp = ft_find_id(data->lstenv, variable);
				        result = ft_replace_string(data->raw_cmd, tmp->id, tmp->value);
			            }
			            else
				        result = ft_replace_string(data->raw_cmd, variable, "");
			        return (result);
		            }
          |->ft_init_data_one_cmd
                 |->ft_redirect
                      |->get_filename
                            in_or_from_file
                 |->signal
                 |->is_builtin
                 |->fork
                 |->signal
                 |->exec_one
                      |->find_command_route_env
                             |->ft_isvariable
                             |->getenv
                             |->command_add
                             |->access
                 |->execve
           |->ft_free_one
           |->ft_multiple_commands
                |->ft_check_pipe_sytax
                |->ft_separate_cmds
                |->pipe
                |->signal
                |->fork
                |->signal
                |->child_process       ?
                |->exec_multiple
                     ->find_command_route_env
                             |->ft_isvariable
                             |->getenv
                             |->command_add
                             |->access
                 |->execve
    |->reset_term_fd
  }
  return (g_status.status);


LEAKS

leaks -atExit -- ./minishell           leaks

echo                                    ok
echo hola                               ok
echo hola hola                          ok
echo "hola"                             ok
echo "hola hola"                        ok
echo " hola hola "                      ok
echo -n hola                            ok
echo "hola " " hola"                    ok
echo $PWD                               ok
echo \n                                 ok
echo -e "\n"                            ok        -e not working but not requested
echo '"Bienvenue sur malekal.com"'      ok        return = Bienvenue sur malekal.com"' and must be: "Bienvenue sur malekal.com"
echo \"hola\"                           ok        return = \"hola\" and must be: "hola"
echo "'Bienvenue sur malekal.com'"      ok        return = hola'" and must be: 'hola'
echo \'hola\'                           ok        return = \'hola\' and must be: 'hola'
echo $'hola'                            ok        return = $'hola' and must be: hola
echo text files are: *.txt              ok        return = text files are: *.txt and must be: text files are: text.txt test.txt
echo "hola hola" > test.txt             ok        crash open: Bad address
echo $PATH                              ok
echo "$PATH"                            ok
echo "rep and files on system: $(LS)"   ok        return = rep and files on system: $(LS) and mus be: text.txt
                                                                                                    builtin
                                                                                                    ...
echo $?                                 ok

exit                                    ok
ctrl-C empty prompt                               crash 
ctrl-D empty prompt                     ok
ctrl-\ empty prompt                               crash  
ctrl-C with text                                  crash  
ctrl-D with text                        ok
ctrl-\ with text                                  crash
ctrl-C after cat